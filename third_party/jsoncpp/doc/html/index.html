<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.0 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a></div>
<h1></h1>
<p>
<h2><a class="anchor" name="_intro">
Introduction</a></h2>
<a href="http://www.json.org/">JSON (JavaScript Object Notation)</a> is a lightweight data-interchange format. It can represents integer, real number, string, an ordered sequence of value, and a collection of name/value pairs.<p>
Here is an example of JSON data: <div class="fragment"><pre class="fragment">
// Configuration options
{
    // Default encoding for text
    "encoding" : "UTF-8",
    
    // Plug-ins loaded at start-up
    "plug-ins" : [
        "python",
        "c++",
        "ruby"
        ],
        
    // Tab indent size
    indent : { length : 3, use_space = true }
}
</pre></div><h2><a class="anchor" name="_features">
Features</a></h2>
<ul>
<li>read and write JSON document</li><li>rewrite JSON document preserving original comments</li></ul>
<p>
<div class="fragment"><pre class="fragment">Json::Value root;   <span class="comment">// will contains the root value after parsing.</span>
Json::Reader reader;
<span class="keywordtype">bool</span> parsingSuccessful = reader.parse( config_doc, root );
<span class="keywordflow">if</span> ( !parsingSuccessful )
{
    <span class="comment">// report to the user the failure and their locations in the document.</span>
    std::cout  &lt;&lt; <span class="stringliteral">"Failed to parse configuration\n"</span>
               &lt;&lt; reader.getFormatedErrorMessages();
    <span class="keywordflow">return</span>;
}

<span class="comment">// Get the value of the member of root named 'encoding', return 'UTF-8' if there is no</span>
<span class="comment">// such member.</span>
std::string encoding = root.get(<span class="stringliteral">"encoding"</span>, <span class="stringliteral">"UTF-8"</span> ).asString();
<span class="comment">// Get the value of the member of root named 'encoding', return a 'null' value if</span>
<span class="comment">// there is no such member.</span>
<span class="keyword">const</span> Json::Value plugins = root[<span class="stringliteral">"plug-ins"</span>];
<span class="keywordflow">for</span> ( <span class="keywordtype">int</span> index = 0; index &lt; plugins.size(); ++index )  <span class="comment">// Iterates over the sequence elements.</span>
   loadPlugIn( plugins[index].asString() );
   
setIndentLength( root[<span class="stringliteral">"indent"</span>].get(<span class="stringliteral">"length"</span>, 3).asInt() );
setIndentUseSpace( root[<span class="stringliteral">"indent"</span>].get(<span class="stringliteral">"use_space"</span>, <span class="keyword">true</span>).asBool() );

<span class="comment">// ...</span>
<span class="comment">// At application shutdown to make the new configuration document:</span>
<span class="comment">// Since Json::Value has implicit constructor for all value types, it is not</span>
<span class="comment">// necessary to explicitely construct the Json::Value object:</span>
root[<span class="stringliteral">"encoding"</span>] = getCurrentEncoding();
root[<span class="stringliteral">"indent"</span>][<span class="stringliteral">"length"</span>] = getCurrentIndentLength();
root[<span class="stringliteral">"indent"</span>][<span class="stringliteral">"use_space"</span>] = getCurrentIndentUseSpace();

Json::StyledWriter writer;
<span class="comment">// Make a new JSON document for the configuration. Preserve original comments.</span>
std::string outputConfig = writer.write( root );
</pre></div><h2><a class="anchor" name="_plinks">
Build instructions</a></h2>
The build instruction are located in the file <a href="README.txt">README.txt</a> in the top-directory of the project.<p>
Permanent link to the lastest revision of the file in subversion: <a href="http://svn.sourceforge.net/viewcvs.cgi/jsoncpp/README.txt?view=markup">lastest README.txt</a><h2><a class="anchor" name="_plinks">
Build instructions</a></h2>
<ul>
<li><a href="http://jsoncpp.sourceforge.net">json-cpp home</a></li><li><a href="http://www.sourceforge.net/projects/jsoncpp">json-cpp sourceforge project</a></li></ul>
<h2><a class="anchor" name="_rlinks">
Related links</a></h2>
<ul>
<li><a href="http://www.json.org/">JSON</a> Specification and alternate language implementations.</li><li><a href="http://www.yaml.org/">YAML</a> A data format designed for human readability.</li><li><a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html">UTF-8 and Unicode FAQ</a>.</li></ul>
<h2><a class="anchor" name="_license">
License</a></h2>
The json-cpp library and this documentation are in Public Domain.<p>
<dl compact><dt><b>Author:</b></dt><dd>Baptiste Lepilleur &lt;<a href="mailto:blep@users.sourceforge.net">blep@users.sourceforge.net</a>&gt; </dd></dl>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 28 14:10:15 2006 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.0 </small></address>
</body>
</html>
