/*
 * WARNING this file was generated by Appcelerator's idl2npapi
 */

<#list getReferencedInterfaces(interface) as ref>
#include "${ref}.h"
</#list>

#include "npSupport.h"
#include "${interface.name}_np.h"
#include "${interface.name}.h"

static void ${interface.name}_initializeIdentifiers(void)
{
    NPN_GetStringIdentifiers(_${interface.name}_pluginPropertyIdentifierNames, _${interface.name}_NumberOfProperties, _${interface.name}_pluginPropertyIdentifiers);
    NPN_GetStringIdentifiers(_${interface.name}_pluginMethodIdentifierNames, _${interface.name}_NumberOfMethods, _${interface.name}_pluginMethodIdentifiers);
}

bool ${interface.name}_identifiersInitialized = false;

bool ${interface.name}_pluginInvokeDefault(NPObject *obj, const NPVariant *args, uint32_t argCount, NPVariant *result)
{
    return false;
}

void ${interface.name}_pluginInvalidate(NPObject *obj)
{
    // Release any remaining references to JavaScript objects.
}

extern ${interface.name}* Create_${interface.name}();

NPObject *${interface.name}_pluginAllocate(NPP npp, NPClass *theClass)
{
    ${interface.name} *newInstance = Create_${interface.name}();

    if (!${interface.name}_identifiersInitialized) {
        ${interface.name}_identifiersInitialized = true;
        ${interface.name}_initializeIdentifiers();
    }

    return newInstance;
}

void ${interface.name}_pluginDeallocate(NPObject *obj)
{
    free(obj);
}

bool ${interface.name}_pluginRemoveProperty (NPObject *npobj, NPIdentifier name) {
  return false;
}

bool ${interface.name}_pluginEnumerate (NPObject *npobj, NPIdentifier **value, uint32_t *count) {
  *count = _${interface.name}_NumberOfProperties + _${interface.name}_NumberOfMethods;

  value = (NPIdentifier**) malloc(sizeof(NPIdentifier*) * (*count));
  int i = 0, index = 0;

  for (i = 0; i < _${interface.name}_NumberOfProperties; i++, index++) value[index] = &_${interface.name}_pluginPropertyIdentifiers[i];
  for (i = 0; i < _${interface.name}_NumberOfMethods; i++, index++) value[index] = &_${interface.name}_pluginMethodIdentifiers[i];

  return true;
}

bool ${interface.name}_pluginHasProperty(NPObject *obj, NPIdentifier name)
{
    int i;
    for (i = 0; i < _${interface.name}_NumberOfProperties; i++)
        if (name ==  _${interface.name}_pluginPropertyIdentifiers[i])
            return true;
    return false;
}

bool ${interface.name}_pluginHasMethod(NPObject *obj, NPIdentifier name)
{
    int i;
    for (i = 0; i <  _${interface.name}_NumberOfMethods; i++)
        if (name ==  _${interface.name}_pluginMethodIdentifiers[i])
            return true;
    return false;
}

<#macro upperCamelCase string>${string[0]?upper_case + string?substring(1)}</#macro>

bool ${interface.name}_pluginGetProperty(NPObject *obj, NPIdentifier name, NPVariant *variant) {
	${interface.name} *instance = (${interface.name} *) obj;
	
	<#list interface.attributes as attribute>
	if (name == _${interface.name}_pluginPropertyIdentifiers[_${interface.name}_${attribute.name}]) {
		${generateToNPVariant(attribute.type, "instance->Get"+attribute.name[0]?upper_case + attribute.name?substring(1) + "()", "variant")};
		return true;
	}
	</#list>
	
	return false;
}

bool ${interface.name}_pluginSetProperty(NPObject *obj, NPIdentifier name, NPVariant *variant) {
	${interface.name} *instance = (${interface.name} *) obj;
	
	<#list interface.attributes as attribute>
	<#if !attribute.readOnly>
	if (name == _${interface.name}_pluginPropertyIdentifiers[_${interface.name}_${attribute.name}]) {
		instance->Set<@upperCamelCase string=attribute.name/>(${generateToClassType(attribute.type, "*variant")});
		VOID_TO_NPVARIANT(*variant);
		return true;
	}
	</#if>
	</#list>
	
	return false;
}

<#macro methodCall method>instance->${method.name}(<#list method.arguments as arg>${generateToClassType(arg.type,"args["+arg_index+"]")}<#if arg_index &lt; method.arguments?size-1>,</#if></#list>)</#macro>

bool ${interface.name}_pluginInvoke(NPObject *obj, NPIdentifier name, const NPVariant *args, uint32_t argCount, NPVariant *result) {
	${interface.name} *instance = (${interface.name} *) obj;
	
	<#list interface.methods as method>
	if (name == _${interface.name}_pluginMethodIdentifiers[_${interface.name}_${method.name}]) {
		<#if method.returnType != "void">
			<#assign cType = toCType(method.returnType)>
			<#if cType == "NPObject *" && hasNativeImpl(cType)>
		${method.returnType} *returnval = <@methodCall method=method/>;
		OBJECT_TO_NPVARIANT(returnval, *result);
			<#else>
		${cType} returnval = <@methodCall method=method/>;
		${generateToNPVariant(method.returnType, "returnval", "result")};
			</#if>
		<#else>
		<@methodCall method=method/>;
		VOID_TO_NPVARIANT(*result);
		</#if>
		
		return true;
	}
	</#list>
	
	return false;
}