/*
 * WARNING this file was generated by Titanium's idlgen
 */
#include "gears/appcelerator/app_command.h"
#include "gears/appcelerator/ruby_util.h"
#include "gears/appcelerator/appcelerator.h"
#include <unistd.h>

DECLARE_DISPATCHER(AppCommand);

<#function upperCamelCase string><#return string[0]?upper_case + string?substring(1)/></#function>
<#function callbackArg method><#list method.arguments as arg><#if arg.type == "callback"><#return arg/></#if></#list><#return null/></#function>
<#function methodHasCallback method><#list method.arguments as arg><#if arg.type == "callback"><#return true/></#if></#list><#return false/></#function>
 
template<>
void Dispatcher<AppCommand>::Init() 
{
	RegisterMethod("App", &AppCommand::App);
	RegisterMethod("Sleep", &AppCommand::Sleep);
<#list interfaces as interface>
<#list interface.methods as method>
	<#list method.arguments as arg>
		<#if arg.type == "callback">
			<#assign execCallback = "Execute" + upperCamelCase(method.name) + "Callback"/>
	RegisterMethod("${interface.name}_${execCallback}", &AppCommand::${interface.name}_${execCallback});
		</#if>
	</#list>
</#list>
</#list>
}

const std::string AppCommand::kModuleName("AppCommand");

AppCommand *appC;

AppCommand::AppCommand() : ModuleImplBaseClass(kModuleName) {
	appC = this;
}

AppCommand::~AppCommand() { }

void AppCommand::App (JsCallContext *context)
{
	debug("AppCommand::App\n");
	std::string16 path;
	JsObject options;	
	JsObject appCallback;
	
	JsArgument argv[] = {
		{ JSPARAM_REQUIRED, JSPARAM_STRING16, &path },
		{ JSPARAM_REQUIRED, JSPARAM_OBJECT, &options },
		{ JSPARAM_REQUIRED, JSPARAM_OBJECT, &appCallback }
	};
	
	context->GetArguments(ARRAYSIZE(argv), argv);
	if (context->is_exception_set()) {
		return;
	}
	
	this->jsObject = &appCallback;
	this->appOptions = &options;
	
	if (path[path.size()-1] != '/') path += STRING16(L"/");
	path += STRING16(L"titanium/appcelerator");
	
	RunScript(this, String16ToUTF8(path).c_str());
}

void AppCommand::Sleep (JsCallContext *context)
{
	debug("AppCommand::Sleep\n");
	
	int ms;
	JsArgument argv[] = {
		{ JSPARAM_REQUIRED, JSPARAM_INT, &ms }
	};
	
	context->GetArguments(ARRAYSIZE(argv), argv);
	if (context->is_exception_set()) return;
	
	usleep(ms);
}

<#list interfaces as interface>
<#list interface.methods as method>
	<#if methodHasCallback(method)>
	
void AppCommand::${interface.name}_Execute${upperCamelCase(method.name)}Callback(JsCallContext *context)
{
	debug("AppCommand::${interface.name}_Execute${upperCamelCase(method.name)}Callback");
	JsObject callbackObject;
	JsArgument argv[] = {
    	{ JSPARAM_REQUIRED, JSPARAM_OBJECT, &callbackObject }
	};
	
	context->GetArguments(ARRAYSIZE(argv), argv);
	
	if (context->is_exception_set()) return;
	
	rb_funcall(this->${interface.name}_${method.name}Callback, rb_intern("callback"), 1, JsObjectToRubyObject(callbackObject));
}
	</#if>
</#list>
</#list>

<#list interfaces as interface>
extern "C" void ${interface.name}_free (void *p) {

}

extern "C" VALUE ${interface.name}_new (VALUE klass) {
	VALUE data = Data_Wrap_Struct(klass, 0, ${interface.name}_free, appC);
	
	return data;
}

<#list interface.methods as method>

extern "C" VALUE ${interface.name}_${method.name} (
	VALUE self<#list method.arguments as arg><#if arg_index <= method.arguments?size-1>, </#if>
	VALUE ${arg.name}</#list>)
{
	debug("${interface.name}.${method.name}\n");

	AppCommand *command = NULL;
	Data_Get_Struct(self, AppCommand, command);
	
	if (command != NULL && command->jsObject != NULL) {
<#if method.returnType != "void">
		JsRootedToken *token;
</#if>
		VALUE argv[] = {<#list method.arguments as arg><#if arg.type != "callback">${arg.name}<#if arg_index < method.arguments?size-1 && method.arguments[arg_index+1].type != "callback">, </#if></#if></#list>};


<#if methodHasCallback(method)>
		command->${interface.name}_${method.name}Callback = ${callbackArg(method).name};
</#if>
		
		if (InvokeJsCallback(command, command->jsObject, "${method.name}",
			ARRAYSIZE(argv), argv, <#if method.returnType != "void">&token<#else>NULL</#if>))
		{
			debug("${interface.name}.${method.name} succeeded.\n");
<#if method.returnType != "void">
	<#if method.returnType?ends_with("string")>
			return JsRootedTokenToRubyValue(token, JSPARAM_STRING16);
	<#elseif method.returnType?ends_with("bool")>
			return JsRootedTokenToRubyValue(token, JSPARAM_BOOL);
	<#elseif method.returnType?ends_with("object")>
			return JsRootedTokenToRubyValue(token, JSPARAM_OBJECT);
	</#if>
</#if>
		} else { debug("${interface.name}.${method.name} failed.\n"); }
	}
	return Qnil;
}
</#list>
</#list>

<#list interfaces as interface>
VALUE ${interface.name}_Class;
</#list>
void AppCommand::DefineClasses()
{
	debug("DefineClasses");
	<#list interfaces as interface>
	${interface.name}_Class = rb_define_class("${interface.name}", rb_cObject);
	rb_define_singleton_method(${interface.name}_Class, "new", RUBY_FUNCTION(${interface.name}_new), 0);
	
		<#list interface.methods as method>
	rb_define_method(${interface.name}_Class, "${method.name}", RUBY_FUNCTION(${interface.name}_${method.name}), ${method.arguments?size});
		</#list>
	</#list>
}